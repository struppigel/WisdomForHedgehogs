{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WisdomForHedgehogs Knowledge base for reverse engineering and malware analysis CPython Note Admonition test note Let's see how this looks like Python import argparse import pefile import struct def extract_resource ( raw_data ): pe = pefile . PE ( data = raw_data ) data_list = [] try : rt_string_idx = [ entry . id for entry in pe . DIRECTORY_ENTRY_RESOURCE . entries ] . index ( pefile . RESOURCE_TYPE [ 'RT_STRING' ]) except : print ( \"resource not found\" ) return None rt_string_directory = pe . DIRECTORY_ENTRY_RESOURCE . entries [ rt_string_idx ] for entry in rt_string_directory . directory . entries : data_rva = entry . directory . entries [ 0 ] . data . struct . OffsetToData size = entry . directory . entries [ 0 ] . data . struct . Size data = pe . get_memory_mapped_image ()[ data_rva : data_rva + size ] data_list . append ( data ) return data_list def extract_strings ( resource_data ): str_list = [] for raw_config in extract_resource ( resource_data ): idx = 0 while ( idx < len ( raw_config )): str_size = struct . unpack ( '<H' , bytearray ( raw_config [ idx : idx + 2 ]))[ 0 ] idx += 2 str_size *= 2 str = raw_config [ idx : idx + str_size ] . decode ( 'utf-16' ) str_list . append ( str ) idx += str_size return str_list def allcome_decrypt ( str ): return '' . join ([ chr ( ord ( c ) - 2 ) for c in str ]) if __name__ == \"__main__\" : parser = argparse . ArgumentParser ( description = 'AllComeClipper Config Extractor' ) parser . add_argument ( '-f' , '--file' , help = 'file' , action = 'store_true' ) parser . add_argument ( 'file' , help = 'file to decode' ) args = parser . parse_args () try : with open ( args . file , \"rb\" ) as f : data = f . read () str_list = extract_strings ( data ) print ( str_list ) for ctr , str in enumerate ( str_list ): if len ( str ) > 0 : print ( ctr , allcome_decrypt ( str )) except : print ( \"unable to extract config\" ) No highlight import argparse import pefile import struct def extract_resource ( raw_data ): pe = pefile . PE ( data = raw_data ) data_list = [] try : rt_string_idx = [ entry . id for entry in pe . DIRECTORY_ENTRY_RESOURCE . entries ] . index ( pefile . RESOURCE_TYPE [ 'RT_STRING' ]) except : print ( \"resource not found\" ) return None rt_string_directory = pe . DIRECTORY_ENTRY_RESOURCE . entries [ rt_string_idx ] for entry in rt_string_directory . directory . entries : data_rva = entry . directory . entries [ 0 ] . data . struct . OffsetToData size = entry . directory . entries [ 0 ] . data . struct . Size data = pe . get_memory_mapped_image ()[ data_rva : data_rva + size ] data_list . append ( data ) return data_list def extract_strings ( resource_data ): str_list = [] for raw_config in extract_resource ( resource_data ): idx = 0 while ( idx < len ( raw_config )): str_size = struct . unpack ( '<H' , bytearray ( raw_config [ idx : idx + 2 ]))[ 0 ] idx += 2 str_size *= 2 str = raw_config [ idx : idx + str_size ] . decode ( 'utf-16' ) str_list . append ( str ) idx += str_size return str_list def allcome_decrypt ( str ): return '' . join ([ chr ( ord ( c ) - 2 ) for c in str ]) if __name__ == \"__main__\" : parser = argparse . ArgumentParser ( description = 'AllComeClipper Config Extractor' ) parser . add_argument ( '-f' , '--file' , help = 'file' , action = 'store_true' ) parser . add_argument ( 'file' , help = 'file to decode' ) args = parser . parse_args () try : with open ( args . file , \"rb\" ) as f : data = f . read () str_list = extract_strings ( data ) print ( str_list ) for ctr , str in enumerate ( str_list ): if len ( str ) > 0 : print ( ctr , allcome_decrypt ( str )) except : print ( \"unable to extract config\" )","title":"WisdomForHedgehogs"},{"location":"#wisdomforhedgehogs","text":"Knowledge base for reverse engineering and malware analysis CPython Note Admonition test note Let's see how this looks like","title":"WisdomForHedgehogs"},{"location":"#python","text":"import argparse import pefile import struct def extract_resource ( raw_data ): pe = pefile . PE ( data = raw_data ) data_list = [] try : rt_string_idx = [ entry . id for entry in pe . DIRECTORY_ENTRY_RESOURCE . entries ] . index ( pefile . RESOURCE_TYPE [ 'RT_STRING' ]) except : print ( \"resource not found\" ) return None rt_string_directory = pe . DIRECTORY_ENTRY_RESOURCE . entries [ rt_string_idx ] for entry in rt_string_directory . directory . entries : data_rva = entry . directory . entries [ 0 ] . data . struct . OffsetToData size = entry . directory . entries [ 0 ] . data . struct . Size data = pe . get_memory_mapped_image ()[ data_rva : data_rva + size ] data_list . append ( data ) return data_list def extract_strings ( resource_data ): str_list = [] for raw_config in extract_resource ( resource_data ): idx = 0 while ( idx < len ( raw_config )): str_size = struct . unpack ( '<H' , bytearray ( raw_config [ idx : idx + 2 ]))[ 0 ] idx += 2 str_size *= 2 str = raw_config [ idx : idx + str_size ] . decode ( 'utf-16' ) str_list . append ( str ) idx += str_size return str_list def allcome_decrypt ( str ): return '' . join ([ chr ( ord ( c ) - 2 ) for c in str ]) if __name__ == \"__main__\" : parser = argparse . ArgumentParser ( description = 'AllComeClipper Config Extractor' ) parser . add_argument ( '-f' , '--file' , help = 'file' , action = 'store_true' ) parser . add_argument ( 'file' , help = 'file to decode' ) args = parser . parse_args () try : with open ( args . file , \"rb\" ) as f : data = f . read () str_list = extract_strings ( data ) print ( str_list ) for ctr , str in enumerate ( str_list ): if len ( str ) > 0 : print ( ctr , allcome_decrypt ( str )) except : print ( \"unable to extract config\" )","title":"Python"},{"location":"#no-highlight","text":"import argparse import pefile import struct def extract_resource ( raw_data ): pe = pefile . PE ( data = raw_data ) data_list = [] try : rt_string_idx = [ entry . id for entry in pe . DIRECTORY_ENTRY_RESOURCE . entries ] . index ( pefile . RESOURCE_TYPE [ 'RT_STRING' ]) except : print ( \"resource not found\" ) return None rt_string_directory = pe . DIRECTORY_ENTRY_RESOURCE . entries [ rt_string_idx ] for entry in rt_string_directory . directory . entries : data_rva = entry . directory . entries [ 0 ] . data . struct . OffsetToData size = entry . directory . entries [ 0 ] . data . struct . Size data = pe . get_memory_mapped_image ()[ data_rva : data_rva + size ] data_list . append ( data ) return data_list def extract_strings ( resource_data ): str_list = [] for raw_config in extract_resource ( resource_data ): idx = 0 while ( idx < len ( raw_config )): str_size = struct . unpack ( '<H' , bytearray ( raw_config [ idx : idx + 2 ]))[ 0 ] idx += 2 str_size *= 2 str = raw_config [ idx : idx + str_size ] . decode ( 'utf-16' ) str_list . append ( str ) idx += str_size return str_list def allcome_decrypt ( str ): return '' . join ([ chr ( ord ( c ) - 2 ) for c in str ]) if __name__ == \"__main__\" : parser = argparse . ArgumentParser ( description = 'AllComeClipper Config Extractor' ) parser . add_argument ( '-f' , '--file' , help = 'file' , action = 'store_true' ) parser . add_argument ( 'file' , help = 'file to decode' ) args = parser . parse_args () try : with open ( args . file , \"rb\" ) as f : data = f . read () str_list = extract_strings ( data ) print ( str_list ) for ctr , str in enumerate ( str_list ): if len ( str ) > 0 : print ( ctr , allcome_decrypt ( str )) except : print ( \"unable to extract config\" )","title":"No highlight"},{"location":"CPython%20Bytecode%20Reversing/","text":"CPython Reversing - Decompilers, Disassemblers, Assemblers When decompiling CPython bytecode, you need to make sure that the decompiler supports the CPython version Decompilers and supported Python versions The most versatile decompiler is probably uncompyle6. decompiler remarks supported versions link uncompyle6 1.4, 2.1-2.7, 3.0-3.8 (diff. branches, see readme) click decompyle3 aka decompile3 recommended to cross check with unpyc37, generally better than uncompyle6 for supported versions 3.7 and 3.8 click uncompyle 2.7 click uncompyle2 by wibiti forked from uncompyle 2.7 click uncompyle2 by Mysterie forked from uncompyle2 by wibiti 2.5, 2.6, 2.7 click unpyc3 by google by google code 3.2 click unpyc3 by figment fork of google code version 3.3 click unpyc37 fork of unpyc3 3.7 click pycdc aka Decompyle++ various, the only decompiler for 3.9+ atm click Disassembler Most decompilers also have disassembly support but there are some dedicated disassemblers. dis is part of Python, supports the currently installed python version python-xdis , supports 1.0 - 3.10, does not rely on installed Python version \ud83d\udd17 Python Bytecode Instructions The disassembler is especially useful if premade tools/decompilers fail to extract anything. Inspecting objects: import rich import malwaremodule rich . inspect ( malwarefunction ) Disassembly: import dis import malwaremodule dis . dis ( malwarefunction ) Assembler python-xasm , for making small patches to existing bytecode","title":"CPython Reversing - Decompilers, Disassemblers, Assemblers"},{"location":"CPython%20Bytecode%20Reversing/#cpython-reversing-decompilers-disassemblers-assemblers","text":"When decompiling CPython bytecode, you need to make sure that the decompiler supports the CPython version","title":"CPython Reversing - Decompilers, Disassemblers, Assemblers"},{"location":"CPython%20Bytecode%20Reversing/#decompilers-and-supported-python-versions","text":"The most versatile decompiler is probably uncompyle6. decompiler remarks supported versions link uncompyle6 1.4, 2.1-2.7, 3.0-3.8 (diff. branches, see readme) click decompyle3 aka decompile3 recommended to cross check with unpyc37, generally better than uncompyle6 for supported versions 3.7 and 3.8 click uncompyle 2.7 click uncompyle2 by wibiti forked from uncompyle 2.7 click uncompyle2 by Mysterie forked from uncompyle2 by wibiti 2.5, 2.6, 2.7 click unpyc3 by google by google code 3.2 click unpyc3 by figment fork of google code version 3.3 click unpyc37 fork of unpyc3 3.7 click pycdc aka Decompyle++ various, the only decompiler for 3.9+ atm click","title":"Decompilers and supported Python versions"},{"location":"CPython%20Bytecode%20Reversing/#disassembler","text":"Most decompilers also have disassembly support but there are some dedicated disassemblers. dis is part of Python, supports the currently installed python version python-xdis , supports 1.0 - 3.10, does not rely on installed Python version \ud83d\udd17 Python Bytecode Instructions The disassembler is especially useful if premade tools/decompilers fail to extract anything. Inspecting objects: import rich import malwaremodule rich . inspect ( malwarefunction ) Disassembly: import dis import malwaremodule dis . dis ( malwarefunction )","title":"Disassembler"},{"location":"CPython%20Bytecode%20Reversing/#assembler","text":"python-xasm , for making small patches to existing bytecode","title":"Assembler"}]}